[[user_guide]]
= User Guide

Creating a custom runtime image can be a challenging task if your application has many non-modular dependencies.
To let you address all possible issues, badass-jlink allows you to configure the `jlink` extension using various properties, methods and script blocks.

The operations required to create a custom runtime image are grouped in several tasks.
This gives you the possibility to tweak a particular step by hooking into the corresponding task
(via `doFirst`, `doLast`, `TaskExecutionListener` or `TaskActionListener`).

== Tasks
<<prepareMergedJarsDir>>:: Unpacks all non-modular dependencies in a designated directory. +
    _depends on_: `jar`
<<createMergedModule>>:: Creates the merged module using the content of the directory prepared by the previous task and adding a module descriptor to it. +
    _depends on_: `prepareMergedJarsDir`
<<createDelegatingModules>>:: For each non-modular dependency, it creates a delegating module, which is an open module
consisting only of a module descriptor. The module descriptor specifies that the delegating module `requires transitive` the merged module. +
    _depends on_: `createMergedModule`
<<prepareModulesDir>>:: Copies all modules needed by _jlink_ to a designated directory. +
    _depends on_: `createDelegatingModules`
<<jlink>>:: Uses the _jlink_ tool to create the custom runtime image.  +
    _depends on_: `prepareModulesDir`
<<jlinkZip>>:: Creates a zip archive of the custom runtime image. +
    _depends on_: `jlink`
<<suggestMergedModuleInfo>>:: Displays the `mergedModule` block that will be used if your `jlink` extension doesn't include one.
  You can use the suggested block as a starting point for your custom `mergedModule` block. +
    _depends on_: `prepareMergedJarsDir`
<<jpackageImage>>:: Uses the https://jdk.java.net/jpackage/[jpackage] tool to create a platform-specific application image.  +
    _depends on_: `prepareModulesDir` +
    _This task is experimental._
<<jpackage>>:: Uses the https://jdk.java.net/jpackage/[jpackage] tool to create a platform-specific application installer.  +
    _depends on_: `jpackageImage` +
    _This task is experimental._

A detailed description of these tasks is given in <<taskDetails>>

== Properties
imageDir:: The directory into which the custom runtime image should be generated. +
(If you use the `targetPlatform` method to generate images for other platforms, the corresponding images will be created in subdirectories of `imageDir`.) +
    _defaultValue_: `_buildDir_/image` +
    _usage example_: `imageDir = file("$buildDir/myapp-image")`
imageZip:: The file into which a zip archive of the custom runtime image should be created. +
    _defaultValue_: `_buildDir_/image.zip` +
    _usage example_: `imageZip = file("$buildDir/myapp-image.zip")`
imageName:: Convenience property for setting the values of both `imageDir` and `imageZip` as follows: +
    pass:[&nbsp;&nbsp;&nbsp;&nbsp;]imageDir <- `_buildDir_/_imageName_` +
    pass:[&nbsp;&nbsp;&nbsp;&nbsp;]imageZip <- `_buildDir_/_imageName_.zip` +
    _usage example_: `imageName = 'hello'`
jlinkBasePath:: The path to the base directory that will be used by the plugin to store intermediate outputs. +
    _defaultValue_: `_buildDir_/jlinkbase` +
    _usage example_: `jlinkBasePath = "$buildDir/my-jlinkbase"`
mainClass:: The main class to be provided as part of the `--launcher` option of _jlink_. +
    _defaultValue_: `project.mainClassName` (from the https://docs.gradle.org/current/userguide/application_plugin.html[Application plugin]) +
    _usage example_: `mainClass = 'org.example.MyApp'`
moduleName:: The module name of this application. +
    _defaultValue_: the module name specified in this application's _module-info.java_ +
    _usage example_: `moduleName = 'org.example.myapp'`
mergedModuleName:: The name of the merged module. +
    _defaultValue_: `_moduleName_.merged.module` +
    _usage example_: `mergedModuleName = 'org.example.myapp.merged.module'`
mergedModuleJarName:: The name of the jar containing the merged module. +
    _defaultValue_: `_archiveBaseName_.merged.module.jar` +
    _usage example_: `mergedModuleJarName = 'my-merged-module.jar'`
options:: A list of options to be passed to _jlink_. +
    _defaultValue_: empty list +
    _usage example_: `options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']`
javaHome:: The path to the JDK providing the tools needed by the plugin (_javac_, _jar_, _jlink_ etc.). +
    _defaultValue_: the first non-empty value from: +
        pass:[&nbsp;&nbsp;&nbsp;&nbsp;] - the `badass.jlink.java.home` system property +
        pass:[&nbsp;&nbsp;&nbsp;&nbsp;] - the `BADASS_JLINK_JAVA_HOME` environment variable +
        pass:[&nbsp;&nbsp;&nbsp;&nbsp;] - the `java.home` system property (only if it points to a JRE containing the `javac`, `jar`, and `jlink` tools) +
        pass:[&nbsp;&nbsp;&nbsp;&nbsp;] - the `JAVA_HOME` environment variable +
    _usage example_: `javaHome = '/usr/lib/jvm/open-jdk'`
configuration:: The name of the Gradle dependency configuration used to execute your application. +
    _defaultValue_: `'runtimeClasspath'` +
    _usage example_: `configuration = 'myAppRuntime'`


== Methods

[maroon]##addOptions##(String... [purple]##options##):: Adds options to be passed to _jlink_.
It is an alternative way of setting the `options` property.
You can call this method multiple times. +
    _usage example_: `addOptions '--no-header-files', '--no-man-pages'`

[maroon]##forceMerge##(String... [purple]##jarPrefixes##):: Instructs the plugin to include all dependencies matching the given prefixes into the merged module.
This method is useful when the plugin should handle one or more modular jars as non-modular.
You can call this method multiple times. +
    _usage example_: `forceMerge 'jakarta.xml.bind-api'`


[maroon]##addExtraDependencies##(String... [purple]##jarPrefixes##):: Instructs the plugin to treat all jars matching the given prefixes as dependencies of the merged module. +
A typical situation where this method is needed involves libraries using JavaFX.
Some libraries do not specify their JavaFX dependencies, because JavaFX was part of the JDK before being removed in Java 11. +
Including `addExtraDependencies("javafx")` into the `jlink` block solves this problem.

[maroon]##addExtraModulePath##(String [purple]##modulePath##):: Instructs the plugin to include the specified `modulePath` in the list of paths passed to the `--module-path` option of jlink. +
You can call this method multiple times. +
    _usage example_: `addExtraModulePath '/usr/lib/jmods'`

[maroon]##targetPlatform##(String [purple]##name##, String [purple]##jdkHome##, List<String> [purple]##options## = []):: Instructs the plugin to generate an application image for a specific platform. +
By default, the plugin generates an image for the platform it runs on.
To create images for other platforms, you need to call the `targetPlatform` method (one call per target platform). +
[purple]##**name**##: an identifier of your choice that will be appended to the `imageDir` and `imageZip` properties to
determine the location of the image directory and of the image archive. +
[purple]##**jdkHome**##: the path to the target platform JDK. +
[purple]##**options**##: an optional list of platform-specific options.
These options will pe passed to _jlink_ in addition to those provided by the `options` property of the `jlink` extension. +
_NOTE_: This is only a convenience method. There is a more powerful `targetPlatform` method (described below), which allows configuring additional parameters of the target platform.

[cols="1,100", frame=none, grid=none]
|===
a| a| .Usage example
[source,groovy]
----
jlink {
    ...
    targetPlatform('linux-x64', '/usr/lib/jvm/jdk_x64_linux_hotspot_11_28')
    targetPlatform('linux-s390x', '/usr/lib/jvm/jdk_s390x_linux_hotspot_11_28',
                                                               ['--endian', 'big'])
    ...
}
----
|===

For a project named `hello`, executing the `jlinkZip` task with the above configuration, and assuming default values for the other properties,
the plugin will generate the platform-specific images in the directories
`build/image/hello-linux-x64` and `build/image/hello-linux-s390x`.
The archived images will be available in `build/image-linux-x64.zip` and `build/image-linux-s390x.zip`.

[maroon]##targetPlatform##(String [purple]##name##, Action<TargetPlatform> [purple]##action##):: This more powerful version of the `targetPlatform` method allows configuring the target platform parameters using a script block. +
[purple]##**name**##: an identifier of your choice that will be appended to the `imageDir` and `imageZip` properties to
determine the location of the image directory and of the image archive. +
[purple]##**action**##: a script block for configuring the target platform parameters. +
&nbsp;&nbsp;&nbsp;&nbsp; _Parameters:_ +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [purple]##**jdkHome**##: the path to the target platform JDK. +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [purple]##**options**##: an optional list of platform-specific options. +
&nbsp;&nbsp;&nbsp;&nbsp; _Methods:_ +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [maroon]##addOptions##(String... [purple]##options##): an alternative way of setting the `options` property. +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [maroon]##addExtraModulePath##(String [purple]##path##): pass the specified path to the `--module-path` option of jlink. +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This method can be used to specify the location of the platform-specific OpenJFX modules.

[cols="1,100", frame=none, grid=none]
|===
a| a| .Usage example
[source,groovy]
----
jlink {
    ...
    targetPlatform("linux-s390x") {
        jdkHome = "/usr/lib/jvm/linux-s390x/jdk-11.0.2+9"
        addOptions("--endian", "big")
        addExtraModulePath("/usr/lib/openjfx/linux-s390x/jmods")
    }
    targetPlatform("mac") {
        jdkHome = "/usr/lib/jvm/mac/jdk-11.0.2+9"
        addExtraModulePath("/usr/lib/openjfx/mac/jmods")
    }
    targetPlatform("win") {
        jdkHome = "/usr/lib/jvm/win/jdk-11.0.2+9"
        addExtraModulePath("/usr/lib/openjfx/win/jmods")
    }
    ...
}
----
|===

[[scriptBlocks]]
== Script blocks

The `jlink` extension can also contain the script blocks detailed below.

=== mergedModule

The `mergedModule` block allows you to configure the module descriptor of the merged module.
It provides a DSL that matches the syntax of the directives in a module declaration file (_module-info.java_),
but it requires quotes around the names of modules, services, and service implementation classes.

The plugin automatically exports all packages found in the merged module, therefore the DSL does not support `exports` directives.

If a `mergedModule` block appears in yout build script, the generated module descriptor will contain the clauses specified in this block.
Otherwise, the module descriptor is created using the algorithm implemented by the `suggestMergedModuleInfo` task.

In many cases the "suggested" descriptor is just the right one for your merged module, so you don't need to provide a `mergedModule` block.
In some other cases the "suggested" descriptor is _almost_ right, in the sense that it only misses one or a few clauses.
In these cases you are allowed to configure only the missing clauses in the `mergedModule` block and instruct the plugin
to add them to the suggested descriptor by setting the attribute `additive` to true.
(The default value of `additive` is false.)


_Usage example_
[source,groovy,indent=0,subs="verbatim,attributes",role="primary"]
.Groovy
----
jlink {
    ...
    mergedModule {
        additive = true
        requires 'java.desktop'
        requires transitive 'java.sql'
        uses 'java.sql.Driver'
        provides 'java.sql.Driver' with 'org.hsqldb.jdbc.JDBCDriver'
    }
    ...
}
----

[source,kotlin,indent=0,subs="verbatim,attributes",role="secondary"]
.Kotlin
----
jlink {
    ...
    mergedModule {
        requires("java.desktop")
        requiresTransitive("java.sql")
        uses("java.sql.Driver")
        provides("java.sql.Driver").with("org.hsqldb.jdbc.JDBCDriver")
    }
    ...
}
----

=== launcher

The plugin generates script files for launching your application.
You can customize these scripts by configuring the following properties in the `launcher` block.

name:: The base name of the script files used to launch your application. +
    _defaultValue_: `project.name`

jvmArgs:: list of JVM arguments to be passed to the java executable. +
    _defaultValue_: empty list

args:: list of arguments to be passed to the application. +
    _defaultValue_: empty list

unixScriptTemplate:: the template for generating the script file for Unix-like systems. +
    _defaultValue_: null (the plugin uses its own template)

windowsScriptTemplate:: the template for generating the script file for Windows-based systems. +
    _defaultValue_: null (the plugin uses its own template)

The plugin uses http://docs.groovy-lang.org/latest/html/api/groovy/text/SimpleTemplateEngine.html[Groovy's SimpleTemplateEngine]
to parse the templates, with the following variables available:

- moduleName
- mainClassName
- jvmArgs
- args

_Usage example_
[source,groovy,indent=0,subs="verbatim,attributes",role="primary"]
.Groovy
----
jlink {
    ...
    launcher {
        name = 'my-app'
        jvmArgs = ['-Dlog4j.debug=true', '-Dlog4j.configurationFile=./log4j2.xml']
        args = ['--user', 'alice']
        unixScriptTemplate = file('unixStartScript.txt')
        windowsScriptTemplate = file('windowsStartScript.txt')
    }
    ...
}
----

[source,kotlin,indent=0,subs="verbatim,attributes",role="secondary"]
.Kotlin
----
jlink {
    ...
    launcher {
        name = "my-app"
        jvmArgs = listOf("-Dlog4j.debug=true", "-Dlog4j.configurationFile=./log4j2.xml")
        args = listOf("--user", "alice")
        unixScriptTemplate = file("unixStartScript.txt")
        windowsScriptTemplate = file("windowsStartScript.txt")
    }
    ...
}
----


=== secondaryLauncher

The plugin can generate script files for additional applications besides the main one.
For each additional application you configure a `secondaryLauncher` block.
This block supports all properties of the `launcher` block and also the following ones:

mainClass:: the main class of this additional application.

moduleName:: the module containing the main class of this additional application. +
    _defaultValue_: the value of the `moduleName` property in the enclosing `jlink` extension


_Usage example_
[source,groovy,indent=0,subs="verbatim,attributes",role="primary"]
.Groovy
----
jlink {
    ...
    secondaryLauncher {
        name = 'my-additional-app'
        mainClass = 'org.example.MyAdditionalApp'
        args = ['--user', 'emma']
    }
    ...
}
----

[source,kotlin,indent=0,subs="verbatim,attributes",role="secondary"]
.Kotlin
----
jlink {
    ...
    launcher {
        name = "my-additional-app"
        mainClass = "org.example.MyAdditionalApp"
        args = listOf("--user", "emma")
    }
    ...
}
----


=== customImage

By default, all application modules are included in the custom runtime image.
This block allows you to create a custom runtime image containing only some of the application modules.

If the `customImage` block is empty, the plugin will create a JRE containing only the JDK modules required by your application.
The plugin figures out by itself which JDK modules are needed, but you can use the below property to request a different set of modules.

jdkModules:: list of JDK modules to be included in the generated image. +
    _defaultValue_: null (the plugin figures out by itself which JDK modules are needed)

jdkAdditive:: if true, the custom image will contain both the modules in the `jdkModules` list and the JDK modules identified as required by the plugin itself.
    _defaultValue_: false

In many cases the "suggested" descriptor is just the right one for your merged module, so you don't need to provide a `mergedModule` block.
In some other cases the "suggested" descriptor is _almost_ right, in the sense that it only misses one or a few clauses.
In these cases you are allowed to configure only the missing clauses in the `mergedModule` block and instruct the plugin
to add them to the suggested descriptor by setting the attribute `additive` to true.
(The default value of `additive` is false.)


appModules:: list of application modules to be included in the generated image. +
    Modules required by those in this list will be automatically included. +
    _defaultValue_: null (all application modules are included)


_Usage example_
[source,groovy,indent=0,subs="verbatim,attributes",role="primary"]
.Groovy
----
jlink {
    ...
    mergedModuleName = 'my.merged.module'
    customImage {
        jdkModules = ['java.desktop', 'java.xml', 'jdk.unsupported']
        appModules = ['my.merged.module']
    }
    ...
}
----

[source,kotlin,indent=0,subs="verbatim,attributes",role="secondary"]
.Kotlin
----
jlink {
    ...
    mergedModuleName = "my.merged.module"
    customImage {
        jdkModules = listOf("java.desktop", "java.xml", "jdk.unsupported")
        appModules = listOf("my.merged.module")
    }
    ...
}
----

=== jpackage

This experimental script block allows you to customize the https://jdk.java.net/jpackage/[jpackage]-based generation of platform-specific application images and installers.

jpackageHome:: The path to the JDK providing the jpackage tool. +
    _defaultValue_: the first non-empty value from: +
        pass:[&nbsp;&nbsp;&nbsp;&nbsp;] - the `badass.jlink.jpackage.home` system property +
        pass:[&nbsp;&nbsp;&nbsp;&nbsp;] - the `BADASS_JLINK_JPACKAGE_HOME` environment variable +
        pass:[&nbsp;&nbsp;&nbsp;&nbsp;] - the `java.home` system property (only if it points to a JRE containing the `jpackage` tool) +
        pass:[&nbsp;&nbsp;&nbsp;&nbsp;] - the `JAVA_HOME` environment variable +
    _usage example_: `jpackageHome = "/usr/lib/jvm/jdk14"`

outputDir:: Convenience property for setting both `imageOutputDir` and
`installerOutputDir` with the value _buildDir_/_outputDir_. +
    _defaultValue_: `"jpackage"` +
    _usage example_: `outputDir = "my-packaging"`


imageOutputDir:: the directory passed as argument to the `--output` option of `jpackage` when executing the `jpackageImage` task .
    _defaultValue_: `_buildDir_/_outputDir_` +
    _usage example_: `imageOutputDir = file("$buildDir/my-packaging-image")`

imageName:: the argument passed to the `--name` option when executing the `jpackageImage` task. +
    _defaultValue_: the `name` value configured in the `launcher` block or  `_project.name_` +
    _usage example_: `imageName = "MyApp"`

imageOptions:: list of additional options to be passed to the `jpackage` executable when executing the `jpackageImage` task. +
    _defaultValue_: empty list +
    _usage example_: `imageOptions = ["--win-console"]`

resourceDir:: the directory passed as argument to the `--resource-dir` option when running `jpackage` to create an application installer.
It is also applicable when creating an application image when you want your own application image instead of the default java image. +
    _usage example_: `resourceDir = file("$buildDir/my-packaging-resources")`

skipInstaller:: boolean value that lets you generate only the platform-specific application image and skip the generation of the platform-specific application installer. +
    _defaultValue_: false +
    _usage example_: `skipInstaller = true`

installerType:: the type of installer to be generated. +
    _defaultValue_: null (all supported types for the current platform will be generated) +
    _usage example_: `installerType = "rpm"`

installerOutputDir:: the directory passed as argument to the `--output` option when running `jpackage` when executing the `jpackage` task.
    _defaultValue_: `_buildDir_/_outputDir_` +
    _usage example_: `installerOutputDir = file("$buildDir/my-packaging-installer")`

installerName:: the argument passed to the `--name` option when running `jpackage` when executing the `jpackage` task. +
    _defaultValue_: the `name` value configured in the `launcher` block or  `_project.name_` +
    _usage example_: `installerName = "MyApp"`

appVersion:: the argument passed to the `--app-version` option when running `jpackage` when executing the `jpackage` and `jpackageImage` tasks. +
    _defaultValue_: the project version +
    _usage example_: `appVersion = "1.0.0"`

jvmArgs:: list of JVM arguments to be passed to the virtual machine. +
    _defaultValue_: the `jvmArgs` value configured in the `launcher` block or an empty list

installerOptions:: list of additional options to be passed to the `jpackage` executable when executing the `jpackage` task. +
    _defaultValue_: empty list +
    _usage example_: `installerOptions = ["--win-console"]`

targetPlatformName:: This property is required only when using the `targetPlatform` method.
    It specifies which of the images produced by jlink should be used as runtime image by jpackage.
    Its value must match the name provided in one of the calls to the `targetPlatform` method. +
    _defaultValue_: null +
    _usage example_: `targetPlatform = "linux"`


_Usage example_
[source,groovy,indent=0,subs="verbatim,attributes",role="primary"]
.Groovy
----
jlink {
    ...
    jpackage {
        jpackageHome = '/usr/lib/jvm/jdk14'
        outputDir = 'my-packaging'
        // imageOutputDir = file("$buildDir/my-packaging-image")
        // installerOutputDir = file("$buildDir/my-packaging-installer")
        imageName = 'MyApp'
        imageOptions = ['--win-console']
        skipInstaller = false
        installerName = 'MyApp'
        installerType = 'msi'
        installerOptions = ['--win-console', '--win-menu', '--win-shortcut']
    }
    ...
}
----

[source,kotlin,indent=0,subs="verbatim,attributes",role="secondary"]
.Kotlin
----
jlink {
    ...
    jpackage {
        jpackageHome = "/usr/lib/jvm/jdk14"
        outputDir = "my-packaging"
        // imageOutputDir = file("$buildDir/my-packaging-image")
        // installerOutputDir = file("$buildDir/my-packaging-installer")
        imageName = "MyApp"
        imageOptions = listOf("--win-console")
        skipInstaller = false
        installerName = "MyApp"
        installerType = "msi"
        installerOptions = listOf("--win-console", "--win-menu", "--win-shortcut")
    }
    ...
}
----

== How it works

The plugin combines all non-modular dependencies into a single jar to which it adds a module descriptor.
If the `jlink` extension contains a `mergedModule` block, its directives will be used to generate the module descriptor.
Otherwise, a module descriptor is created using the algorithm implemented by the `suggestMergedModuleInfo` task.
If the attribute `additive` is set to true in the `mergedModule` block, the generated module descriptor adds the clauses
specified in this block to the "suggested" descriptor.

The non-modular dependencies appear as automatic modules in the original module graph.
The plugin replaces them with _delegating modules_, which are dummy modules containing only a module descriptor that
`requires transitive` the  merged module.

The figure below illustrates this process.

image::merging.png[]

In some situations, the above approach would lead to cyclic dependencies between modules.
For example, in the module graph below the automatic module _org.example.mod1_ requires the proper module _org.example.mod2_.
Because the content of _org.example.mod1_ gets merged into the merged module, the merged module must require _org.example.mod2_.
This in turn requires the delegating module _org.example.mod3_ and hence the merged module.

image::merging.cycle.png[]


To prevent such problems, the plugin automatically detects the modular jars that would be involved in a cycle and treats them
as if they were non-modular.
This means that it also merges these modular jars into the merged module and replaces them with delegating modules.
The figure below shows the resulting module graph.

image::merging.no-cycle.png[]

Sometimes, you may want to have a modular jar treated as non-modular, even if it is not affected by a cyclic dependency problem.
You can do this using the `forceMerge` method.

[[taskDetails]]
== Task details

The following properties denote files and directories used by the plugin tasks:

* [green]##imageDir## - the directory into which the custom runtime image should be generated.
* [olive]##imageZip## - the file into which a zip archive of the custom runtime image should be created.
* [purple]##jlinkBasePath## - the path to the base working directory of the plugin.
The table below shows the variable names of the subdirectories created here and their relative path to the base working directory:

+++
<div style="margin-left: 30px;">
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 70%;">
</colgroup>
<tr><td><b>Variable name</b></td><td><b>Path relative to <i>jlinkBasePath<i></b></td></tr>
<tr><td class="maroon">mergedJarsDir</td><td><code>mergedjars</code></td></tr>
<tr><td class="aqua">tmpMergedModuleDir</td><td><code>tmpmerged</code></td></tr>
<tr><td class="teal">jlinkJarsDir</td><td><code>jlinkjars</code></td></tr>
<tr><td class="navy">tmpJarsDir</td><td><code>tmpjars</code></td></tr>
<tr><td class="fuchsia">tmpModuleInfoDir</td><td><code>tmpmodinfo</code></td></tr>
<tr><td class="blue">delegatingModulesDir</td><td><code>delegating</code></td></tr>
</table>
</div>
+++

[[prepareMergedJarsDir]]
=== prepareMergedJarsDir

[subs="attributes",options="nowrap"]
----
- clean <span class="purple">jlinkBasePath</span>
- copy modular jars required by non-modular jars to <span class="teal">jlinkJarsDir</span>
- copy non-modular jars to <span class="red">nonModularJarsDir</span>
- unpack all jars from <span class="red">nonModularJarsDir</span> into <span class="maroon">mergedJarsDir</span>
- create MANIFEST.MF in <span class="maroon">mergedJarsDir</span>
----


[[createMergedModule]]
=== createMergedModule
[subs="attributes",options="nowrap"]
----
- archive <span class="maroon">mergedJarsDir</span> into <span class="aqua">tmpMergedModuleDir</span>/<i>mergedModuleName</i>.jar
- generate module-info.java for the above merged jar into <span class="navy">tmpJarsDir</span>
- clean <span class="fuchsia">tmpModuleInfoDir</span> and unpack the merged jar in it
- compile the generated module-info.java into <span class="fuchsia">tmpModuleInfoDir</span>
        using <span class="teal">jlinkJarsDir</span> as module-path
- copy the merged jar into <span class="teal">jlinkJarsDir</span>
- insert the module-info.class from <span class="fuchsia">tmpModuleInfoDir</span> into the merged jar
----


[[createDelegatingModules]]
=== createDelegatingModules
[subs="attributes",options="nowrap"]
----
- delete <span class="navy">tmpJarsDir</span>
- for each file in <span class="red">nonModularJarsDir</span>:
    - create delegating module-info.java into <span class="navy">tmpJarsDir</span>/&lt;current-module-name&gt;
    - clean <span class="fuchsia">tmpModuleInfoDir</span> and create MANIFEST.MF in it
    - compile module-info.java into
            <span class="fuchsia">tmpModuleInfoDir</span> with <span class="teal">jlinkJarsDir</span> as module-path
    - create a jar of <span class="fuchsia">tmpModuleInfoDir</span> into <span class="blue">delegatingModulesDir</span>
----


[[prepareModulesDir]]
=== prepareModulesDir
[subs="attributes",options="nowrap"]
----
- copy delegating modules from <span class="blue">delegatingModulesDir</span> to <span class="teal">jlinkJarsDir</span>
- copy modular jars not required by non-modular jars to <span class="teal">jlinkJarsDir</span>
- copy the main module jar from <i>project.jar.archivePath</i> to <span class="teal">jlinkJarsDir</span>
- adjust all module descriptors containing qualified <i>exports</i> or <i>opens</i> clauses
        referring to modules integrated in the merged module. These clauses
        will be changed to also refer to the merged module.
----


[[jlink]]
=== jlink
[subs="attributes",options="nowrap"]
----
- delete <span class="green">imageDir</span>
- create custom runtime image in <span class="green">imageDir</span> by executing <i>jlink</i>
        with modules from <span class="teal">jlinkJarsDir</span>
----


[[jlinkZip]]
=== jlinkZip
[subs="attributes",options="nowrap"]
----
- zip <span class="green">imageDir</span> to <span class="olive">imageZip</span>
----

[[suggestMergedModuleInfo]]
=== suggestMergedModuleInfo
[subs="attributes",options="nowrap"]
----
- determine the modules required by the merged module
- determine the services used by the merged module
- determine the services provided by the merged module
- print the suggested `mergedModule` block
----

**Options**::
`language`:: the DSL for which the _mergedModule_ block should be displayed. +
_default value_: `groovy` +
_accepted values_: `groovy`, `kotlin`, `java` +
_usage example_: `./gradlew suggestMergedModuleInfo --language=kotlin`


[[jpackageImage]]
=== jpackageImage
[subs="attributes",options="nowrap"]
----
- create a platform-specific application image in <font color="saddlebrown">imageOutputDir</font> by executing:
        <i>jpackage --runtime-image <span class="green">imageDir</span> --module-path <span class="teal">jlinkJarsDir</span> ...</i>
----
The properties pass:[<font color="saddlebrown">imageOutputDir</font> and <font color="green">imageDir</font>]
can be configured in the `jpackage` script block.

[[jpackage]]
=== jpackage
[subs="attributes",options="nowrap"]
----
- if <i>skipInstaller</i> is <i>false</i>:
        create a platform-specific application installer in <font color="cadetblue">installerOutputDir</font> by executing:
        <i>jpackage --package-type <font color="midnightblue">installerType</font> --app-image=<font color="saddlebrown">imageOutputDir</font>/<font color="midnightblue">imageName</font> ...</i>
----
The properties pass:[<font color="cadetblue">installerOutputDir</font>, <font color="midnightblue">installerType</font>, <font color="saddlebrown">imageOutputDir</font>, and <font color="midnightblue">imageName</font>]
can be configured in the `jpackage` script block.

If no pass:[<font color="midnightblue">installerType</font>] has been configured, the plugin will run `jpackage` several times, one for each type supported by the current platform.
